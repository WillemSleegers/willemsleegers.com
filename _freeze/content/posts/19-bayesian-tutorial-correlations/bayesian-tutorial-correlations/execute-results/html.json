{
  "hash": "bc9b52d1a72941012f36d58a64042875",
  "result": {
    "markdown": "---\ntitle: \"Bayesian tutorial: Correlation\"\ndescription: \"The third of a series of tutorial posts on Bayesian analyses. In this post I focus on using `brms` to model a correlation.\"\ndate: 2023-02-12\ncategories:\n  - statistics\n  - tutorial\n  - Bayesian statistics\n  - regression\ncode-fold: true\ncode-tools: true\ntoc: true\nformat: \n  html: \n    df-print: kable\n---\n\n\nIn my previous [blog post](../18-bayesian-tutorial-simple-regression/bayesian-tutorial-simple-regression.qmd), I showed how to use `brms` and `tidybayes` to run a simple regression, i.e., a regression with a single predictor. This analysis required us to set three priors: an intercept prior, a sigma prior, and a slope prior. We can simplify this analysis by turning it into a correlational analysis. This will remove the intercept prior and lets us think about the prior for the slope as a standardized effect size, i.e., the correlation. \n\nTo run a correlational analysis we'll need to standardize the outcome and predictor variable, so in the code below I run the setup code as usual and also standardize both variables that we'll be correlating.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(brms)\nlibrary(tidybayes)\n\ndata <- read_csv(\"Howell1.csv\") |>\n  filter(age >= 18) |>\n  mutate(\n    height_z  = (height - mean(height)) / sd(height),\n    weight_z  = (weight - mean(weight)) / sd(weight),\n  )\n\ntheme_set(theme_minimal())\n\ncolors <- c(\"#93CFDB\", \"#1E466E\")\n\noptions(\n  mc.cores = 4,\n  brms.threads = 4,\n  brms.backend = \"cmdstanr\",\n  brms.file_refit = \"on_change\"\n)\n```\n:::\n\n\nThe formula for our model is slightly different compared to the formula of the previous single-predictor model and that's because we can omit the intercept. By standardizing both the outcome and predictor variables, the intercept is guarenteed to be 0. The regression line always passes through the mean of the predictor and outcome variable. The mean of both is 0 because of the standardization and the intercept is the value the outcome takes when the predictor is 0. We could still include a prior for the intercept and set it to 0 (using `constant(0)`) but we can also simply tell `brms` not to estimate it. The formula syntax then becomes: `height_z ~ 0 + weight_z`.\n\nLet's confirm that this means we only need to set two priors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_prior(height_z ~ 0 + weight_z, data = data)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|prior                |class |coef     |group |resp |dpar |nlpar |lb |ub |source  |\n|:--------------------|:-----|:--------|:-----|:----|:----|:-----|:--|:--|:-------|\n|                     |b     |         |      |     |     |      |   |   |default |\n|                     |b     |weight_z |      |     |     |      |   |   |default |\n|student_t(3, 0, 2.5) |sigma |         |      |     |     |      |0  |   |default |\n\n</div>\n:::\n:::\n\n\nIndeed, we're left with a prior for $\\sigma$ and one for `weight_z`, which we can specify either via class `b` or the specific coefficient for `weight_z`. \n\nLet's also write down our model more explicitly, which is the same as the single predictor regression but without the intercept ($\\alpha$).\n$$\\displaylines{heights_i âˆ¼ Normal(\\mu_i, \\sigma) \\\\ \\mu_i = \\beta x_i}$$\n\n## Setting the priors\n\nLet's start with the prior for the slope ($\\beta$). A correlation takes a value that ranges from -1 to 1. If you know absolutely nothing about what kind of correlation to expect, you could set a uniform prior that assign equal probability to every value from -1 to -1. Alternatively, we could use a prior that describes a belief that no correlation is most likely, but with some probability that higher correlations are possible too. This could be done with a normal distribution centered around 0. In the case of this particular model, in which height is regressed onto weight, we can probably expect a sizeable positive correlation. So let's use a skewed normal distribution that puts most of the probability on a positive correlation but is wide enough to allow for a range of correlations, including a negative one. `brms` has the `skew_normal()` function to specify a prior that's a skewed normal distribution. I fiddled around with the numbers a bit and the distribution below is sort of what makes sense to me.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprior <- tibble(r = seq(-1, 1, .01)) %>%\n  mutate(\n    prob = dskew_normal(r, xi = .7, omega = .4, alpha = -3)\n  )\n\nggplot(prior, aes(x = r, y = prob)) +\n  geom_line() +\n  labs(x = \"Slope\", y = \"\")\n```\n\n::: {.cell-output-display}\n![Prior distribution for the correlation](bayesian-tutorial-correlations_files/figure-html/slope-prior-1.png){width=672}\n:::\n:::\n\n\nWhat should the prior for $\\sigma$ be? With the variables standardized, $\\sigma$ is limited to range from 0 to 1. If the predictor explains all the variance of the outcome variable, the residuals will be 0, meaning $\\sigma$ will be 0. If the predictor explains no variance, $\\sigma$ is equal to 1 because it will be similar to the standard deviation of the outcome variable, which is 1 because we've standardized it. Interestingly, this also means that the prior for $\\sigma$ is completely dependent on the prior for the slope, because the slope is what determines how much variance is explained in the outcome variable. I don't know exactly how to deal with this dependency, except to fear it and make sure to carefully inspect the output so that we don't have any problems due to incompatible priors. One way to avoid it entirely is to use a uniform prior that assign equal plausibility to each value between 0 and 1, so let's do that.\n\n## Running the model\n\nWith the priors ready, we can run the model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel <- brm(\n  height_z ~ 0 + weight_z,\n  data = data,\n  family = gaussian(),\n  prior = c(\n    prior(uniform(0, 1), class = \"sigma\", ub = 1),\n    prior(\n      skew_normal(.7, .4, -3),\n      class = \"b\", lb = -1, ub = 1\n    )\n  ),\n  sample_prior = TRUE, ,\n  seed = 4,\n  file = \"models/model.rds\"\n)\n\nmodel\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Family: gaussian \n  Links: mu = identity; sigma = identity \nFormula: height_z ~ 0 + weight_z \n   Data: data (Number of observations: 352) \n  Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;\n         total post-warmup draws = 4000\n\nPopulation-Level Effects: \n         Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nweight_z     0.74      0.03     0.68     0.81 1.00     2166     1876\n\nFamily Specific Parameters: \n      Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsigma     0.66      0.02     0.61     0.71 1.00     3003     2230\n\nDraws were sampled using sample(hmc). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n```\n:::\n:::\n\n\nThe output shows that the estimate for the slope, i.e., the correlation, is 0.74. This is just one number though. Let's visualize the entire distribution, including the prior.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndraws <- model %>%\n  gather_draws(prior_b, b_weight_z) %>%\n  ungroup() %>%\n  mutate(\n    distribution = if_else(\n      str_detect(.variable, \"prior\"), \"prior\", \"posterior\"\n    ),\n    distribution = fct_relevel(distribution, \"prior\")\n  )\n\nggplot(draws, aes(x = .value, fill = distribution)) +\n  geom_histogram(position = \"identity\", alpha = .85) +\n  labs(x = \"Correlation\", y = \"\", fill = \"Distribution\") +\n  scale_fill_manual(values = colors)\n```\n\n::: {.cell-output-display}\n![](bayesian-tutorial-correlations_files/figure-html/correlation-1.png){width=672}\n:::\n:::\n\n\nIt looks like we can update towards a higher correlation and also be more certain about it because the range of the posterior is much narrower than that of our prior. \n\nWhat about sigma? We saw that the correlation between the predictor and outcome is 0.74. Squaring this number gives us the amount of variance explained (0.55), so if we subtract this from 1 we're left with the variance that is unexplained (0.45). Squaring this number to bring it back to a standard deviation gives us 0.67, which matches the estimate for sigma that we saw in the output of `brms`.\n\n## Using a regularizing prior\n\nIn the previous section we used a personal and hopefully informed prior, at least to some degree. What would happen if we instead used a [generic weakly informative prior](https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations)? This is a prior centered at 0 with a standard deviation of 1.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nprior <- tibble(r = seq(-3, 3, .01)) %>%\n  mutate(prob = dnorm(r, mean = 0, sd = 1))\n\nggplot(prior, aes(x = r, y = prob)) +\n  geom_line() +\n  labs(x = \"Slope\", y = \"\")\n```\n\n::: {.cell-output-display}\n![Generic weakly informative prior for the correlation](bayesian-tutorial-correlations_files/figure-html/weakly-informative-slope-prior-1.png){width=672}\n:::\n:::\n\n\nIt's a very broad prior and centered at 0. Does it being centered around 0 push the final estimate closer to a null effect? Let's see by running the model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_generic_prior <- brm(\n  height_z ~ 0 + weight_z,\n  data = data,\n  family = gaussian(),\n  prior = c(\n    prior(uniform(0, 1), class = \"sigma\", ub = 1),\n    prior(\n      normal(0, 1),\n      class = \"b\", lb = -1, ub = 1\n    )\n  ),\n  seed = 4,\n  file = \"models/model_generic_prior_z.rds\"\n)\n\nmodel_generic_prior\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Family: gaussian \n  Links: mu = identity; sigma = identity \nFormula: height_z ~ 0 + weight_z \n   Data: data (Number of observations: 352) \n  Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;\n         total post-warmup draws = 4000\n\nPopulation-Level Effects: \n         Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nweight_z     0.75      0.04     0.68     0.82 1.00     3054     2268\n\nFamily Specific Parameters: \n      Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nsigma     0.66      0.02     0.61     0.71 1.00     2681     2502\n\nDraws were sampled using sample(hmc). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n```\n:::\n:::\n\n\nThe previous estimate of the correlation was 0.74 and now it's 0.75. Apparently the prior did not influence the final estimate. This hopefully alleviates some worries about priors always having a strong impact on the final results and it also shows you don't always need to carefully construct a prior. Of course, in certain cases the prior will have a strong influence, for example when the prior is very strong or when there isn't much data. The prior we used here was broad enough so it didn't exert a strong influence on the final estimates.\n\n## Multiple correlations\n\nWhat if you want to test multiple correlations? There are two ways to do this, as far as I know. The first is to simply run separate models, each testing a single correlation. The second is by creating a model that tests multiple correlations at once.\n\n### One-by-one solution\n\nRunning multiple models to test each correlation is a bit of a chore, but it's made easier with the `update()` function in `brms`, which makes it so that you don't have to write as much code. In the code below I standardize `age` in addition to the two columns we already standardized and run three models in total, correlating `height` with `weight`, `height` with `age`, and `age` with `weight`. I'll use the same generic prior from the last model and repeat the full code for that model, followed by two updates.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- mutate(data, age_z = (age - mean(age)) / sd(age))\n\nr_height_weight <- brm(\n  height_z ~ 0 + weight_z,  \n  data = data, \n  family = gaussian(),\n  prior = c(\n      prior(uniform(0, 1), class = \"sigma\", ub = 1),\n      prior(normal(0, 1), class = \"b\", lb = -1, ub = 1)\n    ), \n  seed = 4,\n  file = \"models/r_height_weight.rds\"\n)\n\nr_height_age <- update(\n  r_height_weight, \n  height_z ~ 0 + age_z, \n  newdata = data,\n  seed = 4,\n  control = list(adapt_delta = .9),\n  file = \"models/r_height_age.rds\"\n)\n\nr_weight_age <- update(\n  r_height_weight, \n  weight_z ~ 0 + age_z, \n  newdata = data,\n  seed = 4,\n  file = \"models/r_weight_age.rds\"\n)\n```\n:::\n\n\nInitially, the model correlating height with age produced a warning about divergent transitions. `brms` produces a helpful warning message with a link to more information about what exactly this means (in short, it means the sampler thinks it's off in estimating the posterior). The message suggests we increase `adapt_delta` above 0.8, so I adjusted the code to set `adapt_delta` to 0.9. Re-running the model got rid of the warning messages.\n\nThe correlations are in the table below (the `Estimate` column).\n\n\n\n::: {.cell tbl-cap='The three correlations and their 95% HDI modeled one-by-one.'}\n\n```{.r .cell-code}\nbind_rows(\n  as_tibble(fixef(r_height_weight)),\n  as_tibble(fixef(r_height_age)),\n  as_tibble(fixef(r_weight_age))\n) %>%\n  mutate(\n    Pair = c(\"height - weight\", \"height - age\", \"weight - age\"),\n    .before = Estimate\n  )\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|Pair            |   Estimate| Est.Error|       Q2.5|      Q97.5|\n|:---------------|----------:|---------:|----------:|----------:|\n|height - weight |  0.7532259| 0.0353075|  0.6844621|  0.8232002|\n|height - age    | -0.1018118| 0.0511314| -0.1965660|  0.0046962|\n|weight - age    | -0.1721501| 0.0521491| -0.2729131| -0.0708909|\n\n</div>\n:::\n:::\n\n\nAnd in the graph below, to show their entire posterior distribution.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncorrelation_draws <- bind_rows(\n  r_height_weight %>%\n    spread_draws(b_weight_z) %>%\n    rename(r = b_weight_z) %>%\n    mutate(pair = \"height - weight\"),\n  r_height_age %>%\n    spread_draws(b_age_z) %>%\n    rename(r = b_age_z) %>%\n    mutate(pair = \"height - age\"),\n  r_weight_age %>%\n    spread_draws(b_age_z) %>%\n    rename(r = b_age_z) %>%\n    mutate(pair = \"weight - age\")\n)\n\nggplot(correlation_draws, aes(x = r, y = pair)) +\n  stat_halfeye() +\n  labs(x = \"Correlation\", y = \"\") +\n  scale_x_continuous(breaks = seq(-1, 1, 0.2))\n```\n\n::: {.cell-output-display}\n![The posterior distributions of the three correlations after modeling them one-by-one.](bayesian-tutorial-correlations_files/figure-html/correlations-plot-1.png){width=672}\n:::\n:::\n\n\n### Simultaneous solution\n\nThe simultaneous solution is trickier but thankfully there's a very helpful [blog post](https://solomonkurz.netlify.app/blog/2019-02-16-bayesian-correlations-let-s-talk-options/) by Solomon Kurz to explain it, so I'll mostly just focus on running the code here and showing the result.\n\nInitially this approach put me off because I did not understand the prior, but then I realized we could simply sample the prior as well and visualize it to show what the prior looks like.\n\nModelling multiple correlations at once requires specifying the formula using multivariate syntax. You can take a look at the code below to see what this syntax looks like. Additionally, we need to append `set_rescor(TRUE)` to the formula to tell brms to calculate residual correlations, which will actually be the correlations we're interested in.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel <- brm(\n  formula = bf(\n    mvbind(height_z, weight_z, age_z) ~ 0,\n    sigma ~ 0\n  ) + set_rescor(TRUE),\n  data = data,\n  family = gaussian(),\n  prior = prior(lkj(2), class = rescor),\n  sample_prior = TRUE,\n  seed = 4,\n  file = \"models/multiple-correlations.rds\"\n)\n\nmodel\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Family: MV(gaussian, gaussian, gaussian) \n  Links: mu = identity; sigma = log\n         mu = identity; sigma = log\n         mu = identity; sigma = log \nFormula: height_z ~ 0 \n         sigma ~ 0\n         weight_z ~ 0 \n         sigma ~ 0\n         age_z ~ 0 \n         sigma ~ 0\n   Data: data (Number of observations: 352) \n  Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;\n         total post-warmup draws = 4000\n\nResidual Correlations: \n                        Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS\nrescor(heightz,weightz)     0.75      0.02     0.71     0.79 1.00     4028\nrescor(heightz,agez)       -0.10      0.05    -0.20     0.00 1.00     4022\nrescor(weightz,agez)       -0.17      0.05    -0.27    -0.06 1.00     4182\n                        Tail_ESS\nrescor(heightz,weightz)     3059\nrescor(heightz,agez)        2855\nrescor(weightz,agez)        3080\n\nDraws were sampled using sample(hmc). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n```\n:::\n:::\n\n\nThe model output shows the correlations in the Residual Correlations section. You'll see that the estimates match the ones we found when running the correlations one-by-one. The 95% CIs also largely match, with some small differences (for more comparisons, see the previously linked blog post by Solomon Kurz).\n\nLet's also plot the posteriors, including their prior.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndraws <- model %>%\n  gather_draws(\n    prior_rescor, rescor__heightz__weightz, rescor__heightz__agez,\n    rescor__weightz__agez\n  ) %>%\n  ungroup() %>%\n  mutate(\n    .variable = case_match(\n      .variable,\n      \"prior_rescor\" ~ \"prior\",\n      \"rescor__heightz__weightz\" ~ \"height-weight\",\n      \"rescor__heightz__agez\" ~ \"height-age\",\n      \"rescor__weightz__agez\" ~ \"weight-age\"\n    ),\n    .variable = fct_relevel(.variable, \"prior\")\n  )\n\nggplot(draws, aes(x = .value, y = .variable)) +\n  stat_halfeye() +\n  labs(x = \"Correlation\", y = \"\") +\n  scale_x_continuous(breaks = seq(-1, 1, 0.2))\n```\n\n::: {.cell-output-display}\n![The posterior distributions of the three correlations, and their prior, after modeling them simultaneously.](bayesian-tutorial-correlations_files/figure-html/simultaneous-correlations-plot-1.png){width=672}\n:::\n:::\n\n\nIt looks like we used a relatively wide prior centered around 0. That's good to know because I had no idea what the `lkj()` prior was doing. Other than that the results look similar to what we found previously.\n\n## Summary\n\nRunning a correlation in `brms` is the same as running a simple regression, except that the outcome and predictor are standardized. Because of the standardization, the intercept can be omitted, thus simplifying the model. The priors are also easier to set as the correlation must range from -1 to and 1 and sigma from 0 to 1. You can also run multiple correlations by running separate models or by modelling them all at once using brms' multivariate syntax.\n\n*This post was last updated on 2023-08-03.*\n",
    "supporting": [
      "bayesian-tutorial-correlations_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}