{
  "hash": "8818f9d97ca884c1b2a722d464d700da",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Type 1 error tests\ndescription: \"A post on how to make sure your type 1 error is what you want it to be.\"\ndate: 2024-01-22\ncategories:\n  - statistics\n  - type-1 error\ncode-fold: show\ncode-tools: true\ntoc: true\ntoc-depth: 2\ndraft: true\n---\n\n\n## Setup\n\nRun the following code to get started.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(MASS)\nlibrary(psych)\nlibrary(tidyverse)\n\ntheme_set(theme_minimal())\n```\n:::\n\n\n## Type 1 error of a single test\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set parameters\nMs <- c(0, 0)\nSDs <- c(1, 1)\nN <- 100\n\n# Prepare parameters\nsigma <- matrix(0, nrow = length(SDs), ncol = length(SDs))\ndiag(sigma) <- SDs^2\n\n# Simulate data\nsamples <- mvrnorm(n = N, mu = Ms, Sigma = sigma)\n\n# Run a t-test\nt.test(samples[, 1], samples[, 2])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tWelch Two Sample t-test\n\ndata:  samples[, 1] and samples[, 2]\nt = -3.0603, df = 196.56, p-value = 0.00252\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -0.7209436 -0.1558913\nsample estimates:\n mean of x  mean of y \n-0.2016723  0.2367452 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nreps <- 10000\n\nsimulate <- function() {\n  samples <- mvrnorm(n = N, mu = Ms, Sigma = sigma)\n  t_test <- t.test(samples[, 1], samples[, 2])\n\n  return(t_test$p.value)\n}\n\nset.seed(1)\n\ntype_1_error <- tibble(rep = 1:reps) |>\n  group_by(rep) |>\n  mutate(p = simulate()) |>\n  ungroup() |>\n  summarize(type_1_error = sum(p < 0.05) / reps)\n\ntype_1_error\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n  type_1_error\n         <dbl>\n1       0.0497\n```\n\n\n:::\n:::\n\n\nFormula: 1 - (1 - 0.05)^2\n\n## Type 1 error of two tests\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set parameters\nMs <- c(0, 0, 0)\nSDs <- c(1, 1, 1)\nN <- 100\n\n# Prepare parameters\nsigma <- matrix(0, nrow = length(SDs), ncol = length(SDs))\ndiag(sigma) <- SDs^2\n\n# Simulate data\nsamples <- mvrnorm(n = N, mu = Ms, Sigma = sigma)\n\n# Run a t-test\nt.test(samples[, 1], samples[, 2])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tWelch Two Sample t-test\n\ndata:  samples[, 1] and samples[, 2]\nt = -0.89946, df = 195.57, p-value = 0.3695\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -0.4153660  0.1551616\nsample estimates:\n  mean of x   mean of y \n-0.10979685  0.02030535 \n```\n\n\n:::\n\n```{.r .cell-code}\nt.test(samples[, 1], samples[, 3])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tWelch Two Sample t-test\n\ndata:  samples[, 1] and samples[, 3]\nt = -1.0934, df = 195.6, p-value = 0.2756\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -0.4435585  0.1271454\nsample estimates:\n  mean of x   mean of y \n-0.10979685  0.04840969 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nreps <- 10000\n\nsimulate <- function() {\n  samples <- mvrnorm(n = N, mu = Ms, Sigma = sigma)\n  t_test_1 <- t.test(samples[, 1], samples[, 2])\n  t_test_2 <- t.test(samples[, 1], samples[, 3])\n\n  return(\n    tibble(\n      p_1 = t_test_1$p.value,\n      p_2 = t_test_2$p.value,\n    )\n  )\n}\n\nset.seed(1)\n\np_values <- tibble(rep = 1:reps) |>\n  group_by(rep) |>\n  reframe(simulate()) |>\n  ungroup()\n\nsummarize(\n  p_values,\n  type_1_error = sum(p_1 < 0.05 | p_2 < 0.05) / reps\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n  type_1_error\n         <dbl>\n1       0.0914\n```\n\n\n:::\n\n```{.r .cell-code}\nsummarize(\n  p_values,\n  type_1_error = sum(p_1 < 0.05 & p_2 < 0.05) / reps\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n  type_1_error\n         <dbl>\n1       0.0098\n```\n\n\n:::\n:::\n\n\n## Type 1 error of many tests\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set parameters\nMs <- rep(0, 10)\nSDs <- rep(1, 10)\nN <- 100\n\n# Prepare parameters\nsigma <- matrix(0, nrow = length(SDs), ncol = length(SDs))\ndiag(sigma) <- SDs^2\n\n# Simulate data\nsamples <- mvrnorm(n = N, mu = Ms, Sigma = sigma)\n\n# Run a t-test\ncorrs <- corr.test(as_tibble(samples), adjust = \"none\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n```\n\n\n:::\n\n```{.r .cell-code}\ncorrs$p |>\n  as_tibble(rownames = \"left\") |>\n  pivot_longer(cols = -left, names_to = \"right\", values_to = \"p\") |>\n  filter(left != right) |>\n  filter(p < .05)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 3\n  left  right      p\n  <chr> <chr>  <dbl>\n1 V2    V10   0.0116\n2 V5    V9    0.0134\n3 V9    V5    0.0134\n4 V10   V2    0.0116\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nreps <- 10000\n\nsimulate <- function() {\n  samples <- mvrnorm(n = N, mu = Ms, Sigma = sigma)\n  corrs <- corr.test(as_tibble(samples), adjust = \"none\")\n\n  return(\n    corrs$p |>\n      as_tibble(rownames = \"left\") |>\n      pivot_longer(cols = -left, names_to = \"right\", values_to = \"p\") |>\n      filter(left != right)\n  )\n}\n\nset.seed(1)\n\np_values <- tibble(rep = 1:reps) |>\n  group_by(rep) |>\n  reframe(simulate()) |>\n  ungroup()\n\np_values |>\n  unite(pair, left, right, sep = \" - \") |>\n  group_by(rep) |>\n  summarize(sig_sum = sum(p < .05)) |>\n  summarize(type_1_error = sum(sig_sum > 0) / reps)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n  type_1_error\n         <dbl>\n1        0.899\n```\n\n\n:::\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}