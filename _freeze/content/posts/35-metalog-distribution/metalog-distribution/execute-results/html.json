{
  "hash": "794f857f8f13a285a0500c2ea91addf4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"The metalog distribution\"\ndate: 2024-04-09\ncategories:\n  - statistics\n  - distributions\n  - simulation\ncode-tools: true\ncode-fold: show\n---\n\n\n\n\nI recently discovered the metalog distribution via [MakeDistribution](https://makedistribution.com/). According to [Wikipedia](https://en.wikipedia.org/wiki/Metalog_distribution), the metalog distribution \"is a flexible continuous probability distribution designed for ease of use in practice\". A distribution that was designed to be easy to use peaked my interest, so in this blog post I try to figure out how to use it and determine whether it is indeed a useful and easy to use distribution.\n\nRun the setup code below in case you want to follow along.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(tidyverse)\nlibrary(rmetalog)\nlibrary(magrittr)\nlibrary(ggdist)\n\ntheme_set(theme_minimal())\n\nmetalog_to_df <- function(x) {\n  metalog |>\n    magrittr::use_series(\"M\") |>\n    tibble::as_tibble() |>\n    tidyr::pivot_longer(\n      cols = -y,\n      names_to = c(\".value\", \"term\"),\n      names_pattern = \"(.)([1-9+])\"\n    ) |>\n    dplyr::mutate(term = as.numeric(term)) |>\n    dplyr::rename(\n      quantile_value = M,\n      pdf_value = m\n    )\n}\n\nformat_label <- function(x, digits = 2) {\n  trimws(format(round(x, digits), nsmall = digits))\n}\n\nformat_interval <- function(x, digits = 2) {\n  paste0(\n    format_label(x$y, digits = digits), \"\\n[\",\n    format_label(x$ymin, digits = digits), \"; \",\n    format_label(x$ymax, digits = digits), \"]\"\n  )\n}\n```\n:::\n\n\n\n\n## The problem with distributions\n\nA common problem with working with distributions is that you need to know which distribution to use for which use-case and then shape the distribution to your liking by giving the distribution's parameters the right values. In some cases this is fairly straightforward, like when you want to model something as a normal distribution with a certain mean and standard devation.\n\nBut what if you want to model, say, how long you think a particular task will take in hours? Here a normal distribution is not well suited and instead you have to use something else, perhaps a Gamma distribution or a lognormal distribution. These distributions take parameters other than a mean and standard deviation and they don't have much intuitive meaning (at least not to me).\n\n## Using the metalog distribution\n\nThe metalog distribution changes all of that because you can simply specify the distribution by giving it a set of quantile-value pairs that are used to form the distribution.\n\nFor example, let's specify three quantile-value pairs below and see how they shape the distribution. \n\nWe use the rmetalog package, which has a function called `metalog()` to create the distribution. We give it the values, the quantiles, and a term limit. The latter refers to how many terms are used in the distribution, with larger term distributions having more flexibility, meaning they better match the quantile-value pairs. The maximum number of terms is the number of quantile-value pairs we give it, so in the example below the maximum is 3.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalues <- c(3, 6, 12)\nquantiles <- c(0.10, 0.5, .9)\n\nmetalog <- metalog(\n  x = values,\n  prob = quantiles,\n  term_limit = 3,\n)\n\nsummary(metalog)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n -----------------------------------------------\n Summary of Metalog Distribution Object\n -----------------------------------------------\n \nParameters\n Term Limit:  3 \n Term Lower Bound:  2 \n Boundedness:  u \n Bounds (only used based on boundedness):  0 1 \n Step Length for Distribution Summary:  0.01 \n Method Use for Fitting:  any \n Number of Data Points Used:  3 \n Original Data Saved:  FALSE \n \n\n Validation and Fit Method\n term valid         method\n    2   yes Linear Program\n    3   yes Linear Program\n```\n\n\n:::\n:::\n\n\n\n\nUsing `summary()` on the output of `metalog()` gives us some information about the distribution, but it doesn't seem particularly useful to me, so let's move on to visualizing the distribution using the `plot()` function. Unfortunately, using `plot()` on the output actually returns two plots, one showing the probability density function (PDF) and the other one showing the cumulative density function (CDF). I prefer looking at the PDF, so that's the one I extract and plot below.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\np <- plot(metalog) |>\n  use_series(\"pdf\")\n\np\n```\n\n::: {.cell-output-display}\n![](metalog-distribution_files/figure-html/metalog-distribution-plot-1.png){width=672}\n:::\n:::\n\n\n\n\nThis shows us two PDF plots. By default the metalog function creates multiple distributions with a different number of terms. In this case, we get one with two terms and one with three terms. The graph with three terms matches exactly the quantile-value pairs we specified but the one with two terms doesn't, which I'll show below by calculating the PDFs at specific quantile values manually using `dmetalog()` and `qmetalog()`, which are equivalents of functions like `dnorm()` and `qnorm()`. I also use some custom functions I loaded in the setup code to extract the metalog values (quantile values and PDF values) as a data frame and plot them using `ggplot()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\npoints <- tibble(\n  quantile_value = values,\n  pdf_value_2 = dmetalog(metalog, quantile_value, term = 2),\n  pdf_value_3 = dmetalog(metalog, quantile_value, term = 3)\n)\n\nlines <- tibble(\n  quantile_value_2 = qmetalog(metalog, quantiles, term = 2),\n  quantile_value_3 = qmetalog(metalog, quantiles, term = 3),\n  pdf_value_2 = dmetalog(metalog, quantile_value_2, term = 2),\n  pdf_value_3 = dmetalog(metalog, quantile_value_3, term = 3),\n)\n\npoints <- points |>\n  pivot_longer(\n    cols = -quantile_value,\n    names_to = \"term\",\n    values_to = \"pdf_value\",\n    names_transform = parse_number\n  )\n\nlines <- lines |>\n  pivot_longer(\n    cols = everything(),\n    names_to = c(\".value\", \"term\"),\n    names_pattern = \"(.+_.+)_([1-9]+)\"\n  ) |>\n  mutate(term = as.numeric(term))\n\ndf <- metalog_to_df(metalog)\n\nggplot(df, aes(x = quantile_value, y = pdf_value)) +\n  facet_wrap(~term) +\n  geom_segment(data = lines, aes(yend = 0), linetype = \"dashed\") +\n  geom_line() +\n  geom_point(data = points) +\n  labs(x = \"Quantile value\", y = \"PDF value\")\n```\n\n::: {.cell-output-display}\n![](metalog-distribution_files/figure-html/metalog-distribution-check-1.png){width=672}\n:::\n:::\n\n\n\n\nThe points show what the PDF values are at each of the quantiles we specified (0.10, 0.50, and 0.90). The lines show the correct quantile-value pairs (e.g., at quantile value 6 the total area of the curve before that value should be 50%). We see that the distribution with three terms perfectly matches our quantile-value pairs while the one with two terms doesn't. The one with two terms has two correct quantile-value pairs (at 3 and 12), but one incorrect one (at 6). I suppose this means that the distribution with the most terms will be a closer match to the specified quantile-value pairs.\n\nThis is cool, though. By simply specifying three quantile-value pairs, we obtained a distribution that matches those values, in this case exactly. This means it becomes much easier to specify a distribution to your liking.\n\n## Does the distribution always match the specified quantile-value pairs?\n\nApparently, the answer is no. We can quickly check this using the `qmetalog()` function to see whether it produces the same values we provided as part of the quantile-value pairs. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nvalues <- c(3, 6, 12)\nquantiles <- c(0.10, 0.5, .9)\n\nmetalog <- metalog(\n  x = values,\n  prob = quantiles,\n  term_limit = 3,\n)\n\nqmetalog(metalog, quantiles, term = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  3  6 12\n```\n\n\n:::\n:::\n\n\n\n\nThe qmetalog() function returns the same values we specified in the `values` variable, which means the distribution is a match. But let's slightly change the values in the quantile-value pairs and check it again.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nvalues <- c(3, 4, 12)\nquantiles <- c(0.10, 0.5, .9)\n\nmetalog <- metalog(\n  x = values,\n  prob = quantiles,\n  term_limit = 3,\n)\n\nqmetalog(metalog, quantiles, term = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  3.000000  4.499306 12.000000\n```\n\n\n:::\n:::\n\n\n\n\nNow the function returns values that are slightly different than the values we provided, so the distribution is not an exact match. This makes sense because the distribution is not fully customizable; it still has some contraints that limits its flexibility. \n\nIf you want to use a distribution that is fully flexible, you have to use other solutions. One such solution is [MakeDistribution](https://makedistribution.com/). They offer other types of distributions that can exactly match the quantile-value pairs, although it's not fully free to use. They also have an [R package](https://github.com/tadamcz/make_distribution_r_client) to access the (paid) API.\n\n## Boundedness\n\nThe metalog distribution also supports setting bounds on the distribution. This means you can specify what the minimum and/or maximum value should be. Below I modify our existing metalog distribution by specifying a lower bound of 0.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmetalog <- metalog(\n  x = values,\n  prob = quantiles,\n  term_limit = 3,\n  boundedness = \"sl\",\n  bound = 0\n)\n\ndf <- metalog_to_df(metalog)\n\ndf |>\n  filter(term == 3) |>\n  ggplot(aes(x = quantile_value, y = pdf_value)) +\n  geom_line() +\n  labs(x = \"Quantile value\", y = \"PDF value\")\n```\n\n::: {.cell-output-display}\n![](metalog-distribution_files/figure-html/metalog-distribution-bounded-1.png){width=672}\n:::\n:::\n\n\n\n\nThe distribution now starts at 0, perfect.\n\n## Simulation\n\nWith the distribution specified to our liking, we can simulate values from the distribution using the `rmetalog()` function. In the code below I simulate 1000 values from the distribution and turn the values into a data frame to plot them as a histogram. I also calculate the quantile values at 10%, 50%, and 90%, which should roughly match the values we specified previously (3, 6, and 12).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhours <- rmetalog(metalog, n = 1000, term = 3)\n\ndf <- tibble(hour = hours)\n\nmedian_qi <- median_qi(hours, .width = .8)\n\nggplot(df, aes(x = hour)) +\n  stat_histinterval(.width = .8) +\n  geom_label(\n    data = median_qi,\n    aes(label = format_interval(median_qi), x = y, y = 0),\n    size = 3,\n    vjust = 0, fill = \"transparent\",\n    label.size = 0, label.padding = unit(0.75, \"lines\")\n  ) +\n  labs(x = \"Hours\", y = \"\")\n```\n\n::: {.cell-output-display}\n![](metalog-distribution_files/figure-html/metalog-distribution-simulation-1.png){width=672}\n:::\n:::\n\n\n\n\nExcellent, we now have a distribution that you could say represents the number of hours to complete a task. We could use this to model how long a project would take to complete by creating separate distributions for each task, sampling values from them, and then summing them together to get a view of how long it will take to complete the project.\n\n## Summary\n\nThe metalog distribution makes it easy to specify a distribution using only quantile-value pairs. You can use the `metalog()` function from the the rmetalog package to specify the distribution, including whether the distribution is bounded or not, and then simulate values from this distribution using the `rmetalog()` function.\n\n*This post was last updated on 2024-07-17.*\n",
    "supporting": [
      "metalog-distribution_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}