{
  "hash": "ff103ae746d21d23f0fbbfd967b1f14d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Formatting numbers\"\ndescription: \"A showcase of the function I use to format numbers.\"\ndate: 2024-05-17\ncategories:\n  - R\n  - function\ncode-tools: true\ncode-fold: show\n---\n\n\n\nThis blog post covers the function I use to format numbers. It's kinda work-in-progress / test place for my function because I know I'm not happy with it yet and, as you can see below, I'll show what output it produces for many different numbers, so I can also use it to see if it does what I want it to do.\n\nRun the following setup code if you want to follow along.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\n## The function\n\nBelow is the function I use. It has 4 arguments:\n\n- `x`: The number to format\n- `trailing_digits`: This is a bit of a weird one. It refers to how many decimals you want, excluding leading zeroes in the decimal part of the number. I often want a number like 0.002121 to be rounded to 0.0021 instead of 0.00, so instead of simply referring to the number of digits, I call it trailing digits.\n- `digits`: This one forces the number of decimals, so setting this to 2 will always show (only) 2 digits\n- `omit_zero`: For numbers that can only range from -1 to 1, the leading zero is often non-informative, so this argument removes that leading zero.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nformat_number <- function(\n    x,\n    trailing_digits = 2,\n    digits = NULL,\n    omit_zero = FALSE) {\n  # Convert the number to a string to use regex to extract different parts\n  # of the number (e.g., decimals)\n  string <- as.character(x)\n\n  # Extract and count decimals\n  decimals <- stringr::str_extract(string, \"(?<=\\\\.).+\")\n  decimals_n <- dplyr::if_else(is.na(decimals), 0, stringr::str_length(decimals))\n\n  # Count number of leading zeroes in the decimals\n  zeroes <- stringr::str_extract(string, \"(?<=\\\\.)0+\")\n  zeroes_n <- dplyr::if_else(is.na(zeroes), 0, stringr::str_length(zeroes))\n\n  # If digits are set, it overrules trailing digits\n  if (!is.null(digits)) {\n    output <- format(round(x, digits), nsmall = digits)\n  } else {\n    trailing_digits <- dplyr::if_else(\n      decimals_n > trailing_digits,\n      trailing_digits + zeroes_n,\n      trailing_digits\n    )\n\n    output <- x |>\n      round(digits = trailing_digits) |>\n      purrr::map2_chr(trailing_digits, formatC, format = \"f\")\n  }\n\n  # Remove leading zero\n  if (omit_zero) output <- stringr::str_remove(output, \"^0\")\n\n  # Replace NAs with NA\n  output <- dplyr::if_else(stringr::str_detect(output, \"NA\"), NA, output)\n\n  return(output)\n}\n```\n:::\n\n\n\n## Testing it out\n\nThe table below shows what kind of output is produced by the function depending on its input. It serves as an illustration of how the function works and as a test for me to see whether the function does what I want it to do.\n\n| Number      | `trailing_digits` | `digits` | `omit_zero` | Result                                                           |\n|-------------|-------------------|----------|-------------|------------------------------------------------------------------|\n| 1           | 0                 | \\-       | `FALSE`     | 1                        |\n| 1           | 2                 | \\-       | `FALSE`     | 1.00                        |\n| 1           | \\-                | 2        | `FALSE`     | 1.00                                 |\n| 1.0         | 2                 | \\-       | `FALSE`     | 1.00                      |\n| 1.02        | 1                 | \\-       | `FALSE`     | 1.02                     |\n| 1.02        | -                 | 1        | `FALSE`     | 1.0                              |\n| 1.02        | 2                 | \\-       | `FALSE`     | 1.02                     |\n| 1.0234      | 2                 | \\-       | `FALSE`     | 1.023                   |\n| 1.00234     | 2                 | \\-       | `FALSE`     | 1.0023                  |\n| 1.00020345  | 2                 | \\-       | `FALSE`     | 1.00020               |\n| 0.123       | 2                 | \\-       | `TRUE`      | .12  |\n| 0.123       | 2                 | \\-       | `FALSE`     | 0.12 |\n| `NA`        | 2                 | \\-       | `FALSE`     | NA    |\n| 1.23, 4.56  | 1                 | \\-       | `FALSE`     | 1.2, 4.6            |\n\n## Limitations\n\nThe function isn't complete yet. For example, I should also add something to deal with very large or very small numbers. I'll update the post when I make adjustments to the function.\n\n## Updates\n\n- The function is now vectorized, so it works when you give it multiple numbers at once.\n- The function can now deal with missing values.\n\n*This post was last updated on 2024-08-21.*",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}