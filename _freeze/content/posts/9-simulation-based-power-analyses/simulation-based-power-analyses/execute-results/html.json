{
  "hash": "dc26230b864d78f8a7b7966da398023b",
  "result": {
    "markdown": "---\ntitle: Simulation-based power analyses\ndescription: \"Simulation-based power analyses make it easy to understand what power is: Power is simply counting how often you find the results you expect to find. Running simulation-based power analyses might be new for some, so in this blog post I present code to simulate data for a range of different scenarios.\"\ndate: 2021-10-23\ncategories:\n  - statistics\n  - power analysis\n  - simulation\ncode-fold: show\ncode-tools: true\nbibliography: references.bib\ntoc: true\ntoc-depth: 2\n---\n\n\n# Introduction\n\nDoing power analyses is hard. I know this from experience, both as a researcher and as a reviewer. As a researcher, I have found power analyses to be difficult because performing a good power analysis requires a thorough understanding of the (hypothesized) data. Understanding one's data is often underestimated, I think. We're very quick to design a study and start data collection, without often knowing what various aspects of our data will look like (e.g., likely correlations between measures, likely standard deviations). As a reviewer, I see that power analyses are difficult because of wrong ideas about what a power analysis actually means. The most common misconception I see is that researchers think they should power their study, rather than the set of analyses they will conduct (see @maxwell2004 for more on this). I also see a lot of power analyses conducted with G\\*Power, which sometimes looks fine, but oftentimes produces results I know to be wrong (usually involving interaction tests). So what to do?\n\nMy favorite way to run power analyses is via simulation. Simulation-based power analyses are more difficult and take longer to setup and run, but they're more pedagogical. Simulations require you to understand your data because you have to define the exact parameters that define your data set (e.g., means, standard deviations, correlations). It also creates a very intuitive understanding of what power is: Power is simply counting how often you find the results you expect to find.\n\nStill, running simulation-based power analyses might be too difficult for some. So in this blog post I present code to simulate data for a range of different scenarios.\n\n## Setup\n\nRun the following code to get started. The most important package here is `MASS`. It contains a function called `mvrnorm()` that enables us to simulate data from a multivariate normal distribution. This means we'll simulate data for scenarios where we have a continuous outcome. I really like this function for simulating data because it has an argument called `empirical` that you can set to `TRUE`, which causes your simulated data to have the exact properties you set (e.g., exactly a mean of 4). This is a great way to check out your simulated data and see if it makes sense.\n\nWe will use the `tidyverse` because we need to prepare the data after simulating it. `mvrnorm()` returns a matrix with each simulated variable as a column. This means we sometimes need to prepare the data so that we can perform the tests we want to run or for visualization purposes.\n\nThe `effectsize` package will be used to inspect the data by calculating standardized effect sizes. This will allow us to check whether the parameters are plausible.\n\nFinally, we sometimes use the `broom` package to extract p-values from the statistical tests that we'll run. This will be necessary to calculate the power because power is (usually) nothing more than the number of significant p-values divided by the number of tests we simulated data for. In a future post I might focus on Bayesian analyses, so we won't be dealing with p-values then, although the logic will be the same.\n\nBesides loading packages, we also set the `s` variable. The value of this variable will determine how many times we'll simulate the data during the power analysis. The higher this number, the more accurate our power estimates will be.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(MASS)\nlibrary(tidyverse)\nlibrary(effectsize)\nlibrary(broom)\nlibrary(viridis)\n\ntheme_set(theme_minimal())\n\noptions(\n  knitr.kable.NA = \"\",\n  digits = 2\n)\n\n# Set number of loops in the power simulations\ns <- 1000\n```\n:::\n\n\nWith the setup out of the way, let's cover our general approach to power analyses:\n\n1.  Simulate the data with fixed properties\n2.  Check the data to see if the data is plausible\n3.  Run the tests we want to run on the data\n4.  Repeat steps 1 to 3 many times, save the p-values, and calculate power\n\nWe'll do this for various scenarios. In each scenario we start by defining the parameters. I'll focus on providing means, standard deviations, and correlations, because those are usually the parameters we report in the results section, so I'm guessing most researchers will have some intuitions about what these parameters mean and whether the results are plausible.\n\nThe `mvrnorm()` function requires that we pass it the sample size, the means, and a variance-covariance matrix. The first two are easy to understand, but the variance-covariance may not be. It's relatively straightforward to convert means, SDs, and correlations to a variance-covariance matrix, though. Variance is simply the standard deviation squared and the covariance is the product of the standard deviations of the two variables and their correlation. You'll see in some scenarios below that this is how I construct the variance-covariance matrix.\n\nNote that the result of each power analysis will be the power, and not the sample size needed to obtain a particular power. This is the same as calculating the post-hoc power in G\\*Power. If you want to figure out what the sample size is for a particular power (e.g., 80%) then you simply change the sample size parameter until you have the power you want.\n\n## One sample *t*-test\n\nThe simplest scenario is where we want to simulate a set of normally distributed values and perform a one sample *t*-test. This requires that we set three parameters: a mean, a standard deviation, and a sample size. We give `mvrnorm()` the sample size (`N`), the mean (`M`), and the variance (`SD^2`). After simulating the data, we give the simulated data a column name and convert the matrix returned by `mvrnorm()` to a data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Parameters\nM <- 0.75\nSD <- 5\nN <- 90\n\n# Simulate once with empirical = TRUE\nsamples <- mvrnorm(N, mu = M, Sigma = SD^2, empirical = TRUE)\n\n# Prepare data\ncolnames(samples) <- \"DV\"\ndata <- as_tibble(samples)\n```\n:::\n\n\nThe next step is to inspect the data to see whether the parameters are plausible. This can be done by converting the parameters to a standardized effect size and by visualizing the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate a standardized effect size\neffect_size <- cohens_d(data$DV)\n\n# Plot the simulated data\nggplot(data, aes(x = DV)) +\n  geom_histogram(alpha = .5, color = \"gray20\", bins = 30) +\n  geom_vline(xintercept = M, linetype = \"dashed\")\n```\n\n::: {.cell-output-display}\n![One sample visualization](simulation-based-power-analyses_files/figure-html/fig-one-sample-t-test-1.png){#fig-one-sample-t-test width=672}\n:::\n:::\n\n\nThe histogram roughly shows that we have a mean of 0.75 and a standard deviation of 5. We also calculated the Cohen's *d* as a measure of the size of the effect. The size of this effect is equal to a Cohen's *d* of 0.15.\n\nNext is the analysis we want to power for---the one-sample *t*-test. The function for this test is `t.test()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt.test(data$DV)\n```\n:::\n\n\nTo calculate the power, we repeat the analysis `s` times. Each time we store the *p*-value so that later we can calculate the proportion of significant results. Since we don't need to inspect the data each time, we skip the data preparation step and use the samples returned by `mvrnorm()` immediately in `t.test()` using R's matrix notation (if you want, you can also prepare the data each time, if you find that easier to understand).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a vector to the store p-values in\np_values <- vector(length = s)\n\n# Loop s times\nfor (i in 1:s) {\n  # Simulate\n  samples <- mvrnorm(N, mu = M, Sigma = SD^2)\n\n  # Run test\n  test <- t.test(samples[, 1])\n\n  # Extract p-value\n  p_values[i] <- test$p.value\n}\n\n# Calculate power\npower <- sum(p_values <= .05) / s * 100\n```\n:::\n\n\nWith the current parameters (N = 90, Cohen's *d* = 0.15), we obtain a power of 32.2%. The power is simply how often we find a significant result, divided by the number of times we looped, multiplied by 100 to give a percentage. You can adjust the sample size parameter and re-run the code until you know which sample size gives you the desired power. You might also want to run the loop a few times to see how consistent your results are (if the results are inconsistent, increase the number of loops by increasing the value of `s`).\n\n## Welch's two sample *t*-test\n\nThe next scenario is one in which there are two groups (e.g., a control condition and a treatment condition) and a single DV. Even in this simple scenario there are already several variations that are important to consider. Do we assume equal variances between groups? Do we assume equal samples sizes? Is the design between or within-subjects? We'll start with assuming unequal variances between the two groups. This means we'll run a Welch's two sample *t*-test. To make it extra fun, we'll also simulate unequal sample sizes.\n\nIf we are interested in a between-subjects design where we assume both unequal variances and samples sizes, we can use the code from the previous scenario and simply run it twice, once for each group. After simulating the data, we convert the simulated matrix of each group to a data frame, add a column indicating the group, and merge the two groups into a single data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Parameters\nM_control <- 5\nM_treatment <- 4\nSD_control <- 1.5\nSD_treatment <- 3\nN_control <- 50\nN_treatment <- 40\n\n# Simulate once with empirical = TRUE\ncontrol <- mvrnorm(N_control,\n  mu = M_control, Sigma = SD_control^2,\n  empirical = TRUE\n)\ntreatment <- mvrnorm(N_treatment,\n  mu = M_treatment, Sigma = SD_treatment^2,\n  empirical = TRUE\n)\n\n# Prepare data\ncolnames(control) <- \"DV\"\ncolnames(treatment) <- \"DV\"\n\ncontrol <- control %>%\n  as_tibble() %>%\n  mutate(condition = \"control\")\n\ntreatment <- treatment %>%\n  as_tibble() %>%\n  mutate(condition = \"treatment\")\n\ndata <- bind_rows(control, treatment)\n```\n:::\n\n\nNext, we inspect the data by calculating a Cohen's *d* and visualizing the results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate a standardized effect size\neffect_size <- cohens_d(DV ~ condition, data = data, pooled_sd = FALSE)\n\n# Visualize the data\nggplot(data, aes(x = condition, y = DV)) +\n  geom_jitter(width = .2, alpha = .25) +\n  stat_summary(fun.data = \"mean_cl_boot\", geom = \"pointrange\") +\n  labs(x = \"Condition\")\n```\n\n::: {.cell-output-display}\n![Two groups visualization (unequal variance)](simulation-based-power-analyses_files/figure-html/fig-welch-t-test-1.png){#fig-welch-t-test width=672}\n:::\n:::\n\n\nThe difference between the two groups is equal to a Cohen's d of 0.42.\n\nTo run a Welch's two-sample *t*-test, we again use the `t.test()` function. R by default does not assume equal variances, so the default is a Welch's two sample *t*-test.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt.test(DV ~ condition, data = data)\n```\n:::\n\n\nThe power analysis looks as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create an empty vector to store the p-values in\np_values <- vector(length = s)\n\n# Loop\nfor (i in 1:s) {\n  # Simulate\n  control <- mvrnorm(N_control, mu = M_control, Sigma = SD_control^2)\n  treatment <- mvrnorm(N_treatment, mu = M_treatment, Sigma = SD_treatment^2)\n\n  # Run test\n  test <- t.test(control[, 1], treatment[, 1])\n\n  # Extract p-value\n  p_values[i] <- test$p.value\n}\n\n# Calculate power\npower <- sum(p_values <= .05) / s * 100\n```\n:::\n\n\nThis produces a power of 45.9% with the current parameters.\n\n## Two sample *t*-test\n\nInstead of assuming unequal variances, we can also assume equal variances and perform a two sample *t*-test. You could adapt the previous scenario by setting the parameters such that the variance in each group is identical, but let's do something different in this scenario. In addition, let's assume that the sample sizes in each group are equal. This means we can simulate the data using a slightly different approach. First, we'll only need 4 parameters. Second, we don't need to separately simulate the data for each group. We can instead use a single `mvrnorm()` call and provide it with the correct variance-covariance matrix. The crucial bit is to only set the variances and set the covariances to 0. If we do it this way, we do need to adjust how we prepare the data. `mvnnorm()` returns a matrix that, when converted to a data frame, results in a wide data frame. That is, the DV of each group is stored in separate columns. This is not [tidy](https://vita.had.co.nz/papers/tidy-data.html \"tidy data\"). We therefore restructure the data to make it long.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Parameters\nM_control <- 5\nM_treatment <- 4\nSD <- 2\nN <- 40\n\n# Prepare parameters\nmus <- c(M_control, M_treatment)\nSigma <- matrix(\n  nrow = 2, ncol = 2,\n  c(\n    SD^2, 0,\n    0, SD^2\n  )\n)\n\n# Simulate once with empirical = TRUE\nsamples <- mvrnorm(N, mu = mus, Sigma = Sigma, empirical = TRUE)\n\n# Prepare data\ncolnames(samples) <- c(\"control\", \"treatment\")\ndata <- as_tibble(samples)\n\ndata_long <- pivot_longer(data,\n  cols = everything(), names_to = \"condition\",\n  values_to = \"DV\"\n)\n```\n:::\n\n\nWe inspect the data with the code from before, substituting `data` with `data_long`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate a standardized effect size\neffect_size <- cohens_d(DV ~ condition, data = data_long)\n\n# Visualize the data\nggplot(data_long, aes(x = condition, y = DV)) +\n  geom_jitter(width = .2, alpha = .25) +\n  stat_summary(fun.data = \"mean_cl_boot\", geom = \"pointrange\") +\n  labs(x = \"Condition\")\n```\n\n::: {.cell-output-display}\n![Two groups visualization (equal variance)](simulation-based-power-analyses_files/figure-html/fig-two-sample-t-test-1.png){#fig-two-sample-t-test width=672}\n:::\n:::\n\n\nWe see a difference between the two conditions with a Cohen's *d* of 0.5.\n\nThis time we run a two sample *t*-test with equal variances assumed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt.test(DV ~ condition, data = data_long, var.equal = TRUE)\n```\n:::\n\n\nAs before, the power analysis code is as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create an empty vector to store p-values in\np_values <- vector(length = s)\n\n# Loop\nfor (i in 1:s) {\n  # Simulate\n  samples <- mvrnorm(N, mu = mus, Sigma = Sigma)\n\n  # Run test\n  test <- t.test(samples[, 1], samples[, 2], var.equal = TRUE)\n\n  # Extract p-value\n  p_values[i] <- test$p.value\n}\n\n# Calculate power\npower <- sum(p_values <= .05) / s * 100\n```\n:::\n\n\nThis produces a power of 60.3% with the current parameters.\n\n## Paired *t*-test\n\nA paired *t*-test is appropriate when we have, for example, data from two groups and we have the same participants in both groups. In other words, the observations belonging to the same participant are likely to be correlated. To calculate power for this scenario, we need to set a correlation parameter. This, in turn, requires that we change the variance-covariance matrix. We need to set the covariances to be equal to the squared standard deviation multiplied by the correlation (remember that a covariance is the standard deviation of one group times the standard deviation of the other group times the correlation between the two).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Parameters\nM_pre <- 5\nM_post <- 4\nSD <- 2\nN <- 40\nr <- 0.75\n\n# Prepare parameters\nmus <- c(M_pre, M_post)\nSigma <- matrix(\n  ncol = 2, nrow = 2,\n  c(\n    SD^2, SD^2 * r,\n    SD^2 * r, SD^2\n  )\n)\n\n# Simulate once with empirical = TRUE\nsamples <- mvrnorm(N, mu = mus, Sigma = Sigma, empirical = TRUE)\n\n# Prepare data\ncolnames(samples) <- c(\"pre\", \"post\")\ndata <- as_tibble(samples)\n\ndata_long <- pivot_longer(data,\n  cols = everything(),\n  names_to = \"condition\", values_to = \"DV\"\n) %>%\n  mutate(condition = fct_relevel(condition, \"pre\"))\n```\n:::\n\n\nLet's plot the means in each group, with a line between the two points representing the means to signify that this data was measured within-subjects. We also calculate another Cohen's *d* to get an impression of the standardized effect size.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate a standardized effect size\neffect_size <- cohens_d(DV ~ condition, data = data_long, paired = TRUE)\n\n# Visualize the data\nggplot(data_long, aes(x = condition, y = DV, group = 1)) +\n  geom_jitter(width = .2, alpha = .25) +\n  stat_summary(fun = \"mean\", geom = \"line\", linetype = 2) +\n  stat_summary(fun.data = \"mean_cl_boot\", geom = \"pointrange\") +\n  labs(x = \"Condition\")\n```\n\n::: {.cell-output-display}\n![Two groups visualization (paired)](simulation-based-power-analyses_files/figure-html/fig-paired-t-test-1.png){#fig-paired-t-test width=672}\n:::\n:::\n\n\nThe difference between the two groups is equal to a Cohen's d of 0.71.\n\nRun the paired *t*-test with `t.test()` and set `paired` to TRUE. I generally favor long data frames, so that's the data frame I use here to run the paired *t*-test. In the power analysis, I use the wide version to minimize the code (and speed up the power analysis).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt.test(DV ~ condition, data = data_long, paired = TRUE)\n```\n:::\n\n\nThe power analysis for this analysis looks as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create an empty vector to store the p-values in\np_values <- vector(length = s)\n\n# Loop\nfor (i in 1:s) {\n  # Simulate\n  samples <- mvrnorm(N, mu = mus, Sigma = Sigma)\n\n  # Run test\n  test <- t.test(samples[, 1], samples[, 2], paired = TRUE)\n\n  # Extract p-value\n  p_values[i] <- test$p.value\n}\n\n# Calculate power\npower <- sum(p_values <= .05) / s * 100\n```\n:::\n\n\nThis produces a power of 98.7% with the current parameters.\n\n## Correlation\n\nTo power for a single correlation, we can actually use most of the code from the previous scenario. The only difference is that we probably don't care about mean differences, so we can set those to 0. If we also assume equal variances, we only need a total of 4 parameters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Parameters\nM <- 0\nSD <- 1\nN <- 40\nr <- 0.5\n\n# Prepare parameters\nmus <- c(M, M)\nSigma <- matrix(\n  ncol = 2, nrow = 2,\n  c(\n    SD^2, SD^2 * r,\n    SD^2 * r, SD^2\n  )\n)\n\n# Simulate once with empirical = TRUE\nsamples <- mvrnorm(N, mu = mus, Sigma = Sigma, empirical = TRUE)\n\n# Prepare data\ncolnames(samples) <- c(\"var1\", \"var2\")\ndata <- as_tibble(samples)\n```\n:::\n\n\nThis time, we plot the data with a scatter plot---a suitable graph for displaying the relationship between two numeric variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Visualize the data\nggplot(data, aes(x = var1, y = var2)) +\n  geom_point(alpha = .25) +\n  geom_smooth(method = \"lm\", color = \"black\")\n```\n\n::: {.cell-output-display}\n![Correlation visualization](simulation-based-power-analyses_files/figure-html/fig-correlation-1.png){#fig-correlation width=672}\n:::\n:::\n\n\nTo perform the statistical test, we run `cor.test()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncor.test(data$var1, data$var2)\n```\n:::\n\n\nThe power analysis:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create an empty vector to store the p-values in\np_values <- vector(length = s)\n\n# Loop\nfor (i in 1:s) {\n  # Simulate\n  samples <- mvrnorm(N, mu = mus, Sigma = Sigma)\n\n  # Run test\n  test <- cor.test(samples[, 1], samples[, 2])\n\n  # Extract p-value\n  p_values[i] <- test$p.value\n}\n\n# Calculate power\npower <- sum(p_values <= .05) / s * 100\n```\n:::\n\n\nThis produces a power of 92.7% with the current parameters.\n\n## 2 *t*-tests\n\nIt gets more interesting when you have three groups that you want to compare. For example, imagine a study with two control conditions and a treatment condition. You probably want to compare the treatment condition to the two control conditions. What is the appropriate analysis in this case? Well, that probably depends on who you ask. Someone might suggest performing an ANOVA to look at the omnibus test, followed up by something like a Tukey HSD. Or maybe you can do an ANOVA/regression in which you compare the treatment condition to the two control conditions combined, using the proper contrast. Both don't make sense to me. In the former case, I don't understand why you would first do an omnibus test if you're going to follow it up with more specific analyses anyway and in the latter case you run into the problem of not knowing whether your treatment condition differs from *both* conditions, which you are likely to predict. Instead, I think the best course of action is to just run two *t*-tests.\n\nThe big thing to take away from this scenario is that we should power for finding a significant effect on *both* tests. We don't power for the 'design' of the study or a single analysis. No, our hypotheses our only confirmed if we find significant differences between the treatment condition and *both* control conditions, which we test with two *t*-tests.\n\nLet's further assume that the variance in the treatment condition is larger than the variance in the control conditions (which is plausible). Let's also assume some dropout in the treatment condition (also possibly plausible). This means we should test the differences with Welch's two sample *t*-tests.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Parameters\nM_control1 <- 5\nM_control2 <- 5\nM_treatment <- 5.6\nSD_control1 <- 1\nSD_control2 <- 1\nSD_treatment <- 1.3\nN_control1 <- 50\nN_control2 <- 50\nN_treatment <- 40\n\n# Simulate once\ncontrol1 <- mvrnorm(N_control1,\n  mu = M_control1, Sigma = SD_control1^2,\n  empirical = TRUE\n)\ncontrol2 <- mvrnorm(N_control2,\n  mu = M_control2, Sigma = SD_control2^2,\n  empirical = TRUE\n)\ntreatment <- mvrnorm(N_treatment,\n  mu = M_treatment, Sigma = SD_treatment^2,\n  empirical = TRUE\n)\n\n# Prepare data\ncolnames(control1) <- \"DV\"\ncolnames(control2) <- \"DV\"\ncolnames(treatment) <- \"DV\"\n\ncontrol1 <- control1 %>%\n  as_tibble() %>%\n  mutate(condition = \"control 1\")\n\ncontrol2 <- control2 %>%\n  as_tibble() %>%\n  mutate(condition = \"control 2\")\n\ntreatment <- treatment %>%\n  as_tibble() %>%\n  mutate(condition = \"treatment\")\n\ndata <- bind_rows(control1, control2, treatment)\n```\n:::\n\n\nWe again inspect the data by visualizing it and calculating standardized effect sizes (two this time; although they are actually identical with the current parameters).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate standardized effect sizes\neffect_size1 <- cohens_d(DV ~ condition,\n  pooled_sd = FALSE,\n  data = filter(data, condition != \"control 2\")\n)\neffect_size2 <- cohens_d(DV ~ condition,\n  pooled_sd = FALSE,\n  data = filter(data, condition != \"control 1\")\n)\n\n# Visualize the data\nggplot(data, aes(x = condition, y = DV)) +\n  geom_jitter(width = .2, alpha = .25) +\n  stat_summary(fun.data = \"mean_cl_boot\", geom = \"pointrange\") +\n  labs(x = \"Condition\")\n```\n\n::: {.cell-output-display}\n![Three groups visualization](simulation-based-power-analyses_files/figure-html/fig-two-t-tests-1.png){#fig-two-t-tests width=672}\n:::\n:::\n\n\nThe treatment condition differs from the two control conditions with a difference equal to a Cohen's *d* of -0.52.\n\nThe statistical analysis consists of two Welch's two sample *t*-tests:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt.test(DV ~ condition, data = filter(data, condition != \"control 1\"))\nt.test(DV ~ condition, data = filter(data, condition != \"control 2\"))\n```\n:::\n\n\nThe power analysis is now more interesting because we want to have enough power to find a significant effect on *both t*-tests. So that means we'll store the p-values of both tests and then count how often we find a *p*-value below .05 for both tests.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create two empty vectors to store the p-values in\np_values1 <- vector(length = s)\np_values2 <- vector(length = s)\n\n# Loop\nfor (i in 1:s) {\n  # Simulate\n  control1 <- mvrnorm(N_control1, mu = M_control1, Sigma = SD_control1^2)\n  control2 <- mvrnorm(N_control2, mu = M_control2, Sigma = SD_control2^2)\n  treatment <- mvrnorm(N_treatment, mu = M_treatment, Sigma = SD_treatment^2)\n\n  # Run tests\n  test1 <- t.test(control1[, 1], treatment[, 1])\n  test2 <- t.test(control2[, 1], treatment[, 1])\n\n  # Extract p-values\n  p_values1[i] <- test1$p.value\n  p_values2[i] <- test2$p.value\n}\n\n# Calculate power\npower <- sum(p_values1 <= .05 & p_values2 <= .05) / s * 100\n```\n:::\n\n\nThe resulting power is 57.9%. Note that this is very different from the power of finding a significant effect of only one of the two tests; which would be equal to a power of 80%. An important lesson to learn here is that with multiple tests, your power may quickly go down, depending on the power for each individual test. You can also calculate the overall power if you know the power of each individual test. If you know you have 80% power for each of two tests, then the overall power will be 80% \\* 80% = 64%. This only works if your analyses are completely independent, though.\n\n## Regression (2 x 2 interaction)\n\nNext, let's look at an interaction effect between two categorical predictors in a regression. Say we have a control condition and a treatment condition and we ran the study in the Netherlands and in Germany. With such a design there is the possibility of an interaction effect. Maybe there's a difference between the control condition and the treatment condition in the Netherlands but not in Germany, or perhaps it is completely reversed, or perhaps only weakened. The exact pattern determines the strength of the interaction effect. If an effect in one condition completely flips in another condition, we have the strongest possible interaction effect (i.e., a crossover interaction). If the effect is merely weaker in one condition rather than another, then we only have a weak interaction effect (i.e., an attenuated interaction effect).\n\nNot only does the expected pattern of the interaction determine the expected effect size of the interaction, it also affects which analyses you should run. Finding a significant interaction effect does not mean that the interaction effect you found actually matches what you hypothesized. If you expect a crossover interaction, but you only find an attenuated interaction, you're wrong. And vice versa as well. The issue is more complicated when you expect an interaction in which the effect is present is one condition but absent in another. You then should test whether the effect is indeed absent, which is a bit tricky with frequentist statistics (although see [this](https://journals.sagepub.com/doi/10.1177/2515245918770963 \"Equivalence testing\")). Hypothesizing a crossover interaction is probably the easiest. I think you don't even need to run an interaction test in that case. Instead, you can just run two t-tests and test whether both are significant, with opposite signs.\n\nIn this scenario, let's cover what is possibly the most common interaction in psychology---an attenuated interaction with the effect being present in both conditions, but smaller in one than in the other. This means we want a significant difference between the two conditions in each country, as well as a significant interaction effect.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Parameters\nM_control_NL <- 4\nM_control_DE <- 4\nM_treatment_NL <- 5\nM_treatment_DE <- 6\nSD <- 2\nN <- 40\n\n# Prepare parameters\nmus <- c(M_control_NL, M_control_DE, M_treatment_NL, M_treatment_DE)\nSigma <- matrix(\n  ncol = 4, nrow = 4,\n  c(\n    SD^2, 0, 0, 0,\n    0, SD^2, 0, 0,\n    0, 0, SD^2, 0,\n    0, 0, 0, SD^2\n  )\n)\n\n# Simulate once\nsamples <- mvrnorm(N, mu = mus, Sigma = Sigma, empirical = TRUE)\n\n# Prepare data\ncolnames(samples) <- c(\n  \"control_NL\", \"control_DE\", \"treatment_NL\", \"treatment_DE\"\n)\n\ndata <- samples %>%\n  as_tibble() %>%\n  pivot_longer(\n    cols = everything(),\n    names_to = c(\"condition\", \"country\"),\n    names_sep = \"_\",\n    values_to = \"DV\"\n  )\n```\n:::\n\n\nWhen it comes to interaction effects, it's definitely a good idea to visualize the data. In addition, we calculate the effect size of the difference between the control and treatment condition for each country.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate effect size per country\neffect_size_NL <- cohens_d(DV ~ condition, data = filter(data, country == \"NL\"))\neffect_size_DE <- cohens_d(DV ~ condition, data = filter(data, country == \"DE\"))\n\n# Visualize the interaction effect\nggplot(data, aes(x = condition, y = DV)) +\n  geom_jitter(width = .2, alpha = .25) +\n  stat_summary(fun.data = \"mean_cl_boot\", geom = \"pointrange\") +\n  facet_grid(~country) +\n  labs(x = \"Condition\")\n```\n\n::: {.cell-output-display}\n![2x2 interaction visualization](simulation-based-power-analyses_files/figure-html/fig-lm-2-by-2-1.png){#fig-lm-2-by-2 width=672}\n:::\n:::\n\n\nThe graph shows that the difference between the control and treatment condition indeed seems to be larger in Germany than in the Netherlands. In the Netherlands, the effect size is equal to a Cohen's *d* of -0.5. In Germany, it's -1.\n\nA regression analysis can be used to test the interaction effect and whether the effect is present in each country. We do need the run the regression twice in order to get the effect of treatment in each country. By default, Germany is the reference category (DE comes before NL). So if we switch the reference category to NL, we get the effect of treatment in the Netherlands.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Regression with DE as the reference category\nmodel_DE <- lm(DV ~ condition * country, data = data)\nsummary(model_DE)\n\n# Regression with NL as the reference category\ndata <- mutate(data, country = fct_relevel(country, \"NL\"))\n\nmodel_NL <- lm(DV ~ condition * country, data = data)\nsummary(model_NL)\n```\n:::\n\n\nOur interest is in the two treatment effects and the interaction effect (which is the same in both models). This means that we want to save 3 p-values in the power analysis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create three empty vectors to store the p-values in\np_values_NL <- vector(length = s)\np_values_DE <- vector(length = s)\np_values_interaction <- vector(length = s)\n\n# Loop\nfor (i in 1:s) {\n  # Simulate\n  samples <- mvrnorm(N, mu = mus, Sigma = Sigma)\n\n  # Prepare data\n  colnames(samples) <- c(\n    \"control_NL\", \"control_DE\", \"treatment_NL\",\n    \"treatment_DE\"\n  )\n\n  data <- samples %>%\n    as_tibble() %>%\n    pivot_longer(\n      cols = everything(),\n      names_to = c(\"condition\", \"country\"),\n      names_sep = \"_\",\n      values_to = \"DV\"\n    )\n\n  # Run tests\n  model_DE <- lm(DV ~ condition * country, data = data)\n\n  data <- mutate(data, country = fct_relevel(country, \"NL\"))\n  model_NL <- lm(DV ~ condition * country, data = data)\n\n  # Extract p-values\n  model_NL_tidy <- tidy(model_NL)\n  model_DE_tidy <- tidy(model_DE)\n\n  p_values_NL[i] <- model_NL_tidy$p.value[2]\n  p_values_DE[i] <- model_DE_tidy$p.value[2]\n  p_values_interaction[i] <- model_NL_tidy$p.value[4]\n}\n\n# Calculate power\npower <- sum(p_values_NL <= .05 & p_values_DE <= .05 &\n  p_values_interaction <= .05) / s * 100\n```\n:::\n\n\nThe overall power for this scenario is 9.6%. If you instead only look at the power of the interaction test, you get a power of 35.1%. The difference shows that it matters whether you follow up your interaction test with the analyses that confirm the exact pattern of the interaction test. Also note that these analyses are not independent, so it's not straightforward to calculate the overall power. Simulation makes it relatively easy.\n\n## Regression (2 groups * 1 continuous interaction)\n\nAnother scenario involves having multiple groups (e.g., conditions) and a continuous measure that interacts with the group. In other words, this scenario consists of having different correlations, with the correlation between a measure and an outcome depending on the group.\n\nWe can simulate a scenario like that by simulating multiple correlations and then merging the data together. In the scenario below, I simulate a correlation of size 0 in one group (i.e., control group) and a correlation of .5 in another group (i.e., treatment group).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Parameters\nM_outcome <- 4\nSD_outcome <- 1\nM_control <- 4\nSD_control <- 1\nM_treatment <- 4\nSD_treatment <- 1\n\nr_control <- 0.1\nr_treatment <- 0.5\n\nN <- 40\n\n# Prepare parameters\nmus_control <- c(M_control, M_outcome)\nSigma_control <- matrix(\n  ncol = 2, nrow = 2,\n  c(\n    SD_control^2, SD_control * SD_outcome * r_control,\n    SD_control * SD_outcome * r_control, SD_outcome^2\n  )\n)\n\nmus_treatment <- c(M_treatment, M_treatment)\nSigma_treatment <- matrix(\n  ncol = 2, nrow = 2,\n  c(\n    SD_treatment^2, SD_treatment * SD_outcome * r_treatment,\n    SD_treatment * SD_outcome * r_treatment, SD_outcome^2\n  )\n)\n\n# Simulate once with empirical = TRUE\nsamples_control <- mvrnorm(\n  N,\n  mu = mus_control,\n  Sigma = Sigma_control, empirical = TRUE\n)\nsamples_treatment <- mvrnorm(\n  N,\n  mu = mus_treatment,\n  Sigma = Sigma_treatment, empirical = TRUE\n)\n\n# Prepare data\ncolnames(samples_control) <- c(\"measure\", \"outcome\")\ndata_control <- as_tibble(samples_control)\ndata_control <- mutate(data_control, condition = \"Control\")\n\ncolnames(samples_treatment) <- c(\"measure\", \"outcome\")\ndata_treatment <- as_tibble(samples_treatment)\ndata_treatment <- mutate(data_treatment, condition = \"Treatment\")\n\ndata <- bind_rows(data_control, data_treatment)\n```\n:::\n\n\nLet's visualize the simulated data to see whether we indeed observe a correlation in the treatment condition and none in the control condition.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data, aes(x = measure, y = outcome)) +\n  facet_grid(~condition) +\n  geom_point(alpha = .25) +\n  geom_smooth(method = \"lm\", color = \"black\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n:::\n\n::: {.cell-output-display}\n![2 (group) x 1 (continuous) interaction visualization](simulation-based-power-analyses_files/figure-html/fig-lm-2-by-1-1.png){#fig-lm-2-by-1 width=672}\n:::\n:::\n\n\nLooks correct. \n\nAnalyzing this data is a bit trickier. To confirm our hypotheses we need to show that:\n1. There is no correlation in the Control condition\n2. There is a positive correlation in the Treatment condition\n3. There is a significant interaction effect.\n\nThe first one is rather difficult because it's not straightforward to prove a null using frequentist statistics. We could do an equivalence test of some sort, but I'll just keep it simple and count the test as successful if we find a non-significant p-value.\n\nBesides that, this scenario is similar to the previous one. We run two regression models in order to get the relevant p-value. The first model is to obtain the p-value of the slope between the measure and outcome in the control condition, as well as the p-value of the interaction. The second model is to obtain the p-value of the slope in the treatment condition.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create three empty vectors to store the p-values in\np_values_control <- vector(length = s)\np_values_treatment <- vector(length = s)\np_values_interaction <- vector(length = s)\n\n# Loop\nfor (i in 1:s) {\n  # Simulate\n  samples_control <- mvrnorm(N, mu = mus_control, Sigma = Sigma_control)\n  samples_treatment <- mvrnorm(N, mu = mus_treatment, Sigma = Sigma_treatment)\n\n  # Prepare data\n  colnames(samples_control) <- c(\"measure\", \"outcome\")\n  data_control <- as_tibble(samples_control)\n  data_control <- mutate(data_control, condition = \"Control\")\n\n  colnames(samples_treatment) <- c(\"measure\", \"outcome\")\n  data_treatment <- as_tibble(samples_treatment)\n  data_treatment <- mutate(data_treatment, condition = \"Treatment\")\n\n  data <- bind_rows(data_control, data_treatment)\n\n  # Run tests\n  model_control <- lm(outcome ~ condition * measure, data = data)\n  data <- mutate(data, condition = fct_relevel(condition, \"Treatment\"))\n  model_treatment <- lm(outcome ~ condition * measure, data = data)\n\n  # Extract p-values\n  model_control_tidy <- tidy(model_control)\n  model_treatment_tidy <- tidy(model_treatment)\n\n  p_values_control[i] <- model_control_tidy$p.value[3]\n  p_values_treatment[i] <- model_treatment_tidy$p.value[3]\n  p_values_interaction[i] <- model_control_tidy$p.value[4]\n}\n\n# Calculate power\npower <- sum(p_values_control > .05 & p_values_treatment <= .05 &\n  p_values_interaction <= .05) / s * 100\n```\n:::\n\n\nThe overall power for this scenario is 44.9%. It matters less now whether we power for the whole set of analyses or just the slope in the treatment condition because the interaction effect is wholly driven by this slope.\n\n# Conclusion\n\nIn this post I presented code to perform a simulated-based power analysis for several scenarios. In the future I hope to expand on the scenarios, but I think the scenarios included so far already reveal a few interesting things. In some cases, it's rather trivial to simulate the data. The `mvrnorm()` function works wonders for simulating the data by letting you set `empirical` to `TRUE`, thereby allowing you to inspect the simulated data. More importantly, though, I think that simulation-based power analyses are pedagogical. It takes the magic out of power analyses because power is nothing more than counting how often you find the significant results you expect to find. Not only that, the simulation approach also means that if you can simulate the data, you can calculate the power. Maybe that's easier said than done, but that's where my example code comes in. Hopefully it provides you with the code you can adapt to your own scenario so you can run the correct power analysis.\n\n*This post was last updated on 2023-04-11.*\n",
    "supporting": [
      "simulation-based-power-analyses_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}