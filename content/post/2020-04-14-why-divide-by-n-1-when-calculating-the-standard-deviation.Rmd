---
title: Why divide by N - 1 when calculating the standard deviation?
author: ''
date: '2020-04-14'
slug: why-divide-by-n-1-when-calculating-the-standard-deviation
categories: []
tags: []
math: true
---

```{r setup, echo = FALSE, message = FALSE}
# Load packages
library(tidyverse)
library(knitr)

# Set ggplot settings
theme_set(theme_bw(base_size=12))
theme_update(panel.background = element_rect(fill = "transparent", colour = NA),
             plot.background = element_rect(fill = "transparent", colour = NA))
opts_chunk$set(dev.args=list(bg="transparent"))
```


The formula for calculating the variance is:

$$\frac{\sum(x_i - \overline{x})^2}{n}$$

This makes sense. The variance is a measure of the dispersion around the mean, so we calculate all the deviations from the mean ($x_i - \overline{x}$) and sum them. We then divide this sum by the number of observations as a scaling factor. If we ignore this number, we could get a very high variance simply by observing a lot of data. So, to fix that problem, we divide by the total number of observations.

However, this is the formula for the *population* variance. The formula for calculating the variance of a sample is:

$$\frac{\sum(x_i - \overline{x})^2}{n - 1}$$

Why do we divide by *n* - 1 when calculating the variance of a sample?

Let's see what happens if we calculate the variance by dividing by *n*, rather than *n* - 1.

```{r, echo = FALSE}
s <- 10000
ns <- c(5, 10, 25, 50, 100, 250)
vars_biased <- vector(length = s)
vars_unbiased <- vector(length = s)

data <- tibble(n = ns, biased = NA, unbiased = NA)

for (i in 1:length(ns)) {
  n <- ns[i]
  
  for (j in 1:s) {
    x <- rnorm(n, mean = 5, sd = 2)
    vars_biased[j] <- sum((x - mean(x))^2)/length(x)
    vars_unbiased[j] <- sum((x - mean(x))^2)/(length(x)-1)
  }
  
  data$biased[i] <- mean(vars_biased)
  data$unbiased[i] <- mean(vars_unbiased)
}

data %>%
  gather("variance", "value", biased, unbiased) %>%
  ggplot(aes(x = n, y = value, color = variance)) +
    geom_line() +
    geom_point() +
    geom_hline(yintercept = 2^2, linetype = 2) +
    # coord_cartesian(ylim = c(1.5, 2.25)) +
    labs(x = "Sample size (n)", y = "Variance")
```