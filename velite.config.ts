import { defineConfig, defineCollection, defineLoader, s, type Loader } from "velite"
import path from "path"
import fs from "fs"
import matter from "gray-matter"

// Custom loader for markdown files generated by Quarto
const quartoMarkdownLoader: Loader = {
  test: /\.md$/,
  load: async (file) => {
    const mdPath = file.path

    // Extract post slug from path (e.g., "posts/99-test-workflow/file.md" -> "99-test-workflow")
    const relativePath = path.relative(path.join(process.cwd(), 'content'), mdPath)
    const pathParts = relativePath.split(path.sep)
    const postSlug = pathParts[1] // posts/[THIS-PART]/file.md

    try {
      // Read the markdown file (should already be rendered by Quarto)
      let mdContent = fs.readFileSync(mdPath, 'utf-8')

      // Find and copy figure files, update paths in markdown
      const postDir = path.dirname(mdPath)
      const mdBasename = path.basename(mdPath, '.md')
      const defaultFigureDir = path.join(postDir, `${mdBasename}_files`, 'figure-commonmark')
      const targetFigureDir = path.join(process.cwd(), 'public', 'figures', postSlug)

      if (fs.existsSync(defaultFigureDir)) {
        // Create target directory if it doesn't exist
        if (!fs.existsSync(targetFigureDir)) {
          fs.mkdirSync(targetFigureDir, { recursive: true })
        }

        // Copy all files from default figure dir to target (keep originals for Quarto preview)
        const figureFiles = fs.readdirSync(defaultFigureDir)
        for (const file of figureFiles) {
          const sourcePath = path.join(defaultFigureDir, file)
          const targetPath = path.join(targetFigureDir, file)
          fs.copyFileSync(sourcePath, targetPath)
        }

        // Update paths in markdown
        const oldPath = `${mdBasename}_files/figure-commonmark/`
        const newPath = `/figures/${postSlug}/`
        mdContent = mdContent.replaceAll(oldPath, newPath)

        console.log(`✓ Copied figures for ${relativePath}`)
      }

      // Parse frontmatter and content
      const { data, content } = matter(mdContent)

      // Convert Date objects to ISO strings for Velite schema
      if (data.date instanceof Date) {
        data.date = data.date.toISOString()
      }
      if (data.updated instanceof Date) {
        data.updated = data.updated.toISOString()
      }

      // Return in the format Velite expects: { data: object }
      return {
        data: {
          ...data,
          content: content,
        }
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error)
      console.error(`✗ Failed to process ${relativePath}: ${errorMessage}`)
      throw error
    }
  }
}

const computedFields = <T extends { slug: string }>(data: T) => ({
  ...data,
  slug: data.slug.split("/").slice(2).join("/"),
})

const posts = defineCollection({
  name: "Post",
  pattern: "posts/**/*.md",
  schema: s
    .object({
      slug: s.path(),
      title: s.string().max(99),
      description: s.string().max(999).optional(),
      date: s.isodate(),
      updated: s.isodate().optional(),
      tags: s.array(s.string()).optional(),
      draft: s.boolean().optional(),
      toc: s.boolean().optional().default(false),
      content: s.raw(), // Keep content as raw markdown
    })
    .transform(computedFields),
})

export default defineConfig({
  root: "content",
  collections: { posts },
  loaders: [quartoMarkdownLoader],
})
